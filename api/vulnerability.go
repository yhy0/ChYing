package api

import (
	"context"
	"time"

	"github.com/yhy0/ChYing/pkg/Jie/pkg/output"
	"github.com/yhy0/logging"
)

type VulnerabilityAPI struct{}

type VulnerabilityData struct {
	ID          int       `json:"id"`
	Plugin      string    `json:"plugin"`
	Target      string    `json:"target"`
	VulnType    string    `json:"vuln_type"`
	Level       string    `json:"level"`
	Description string    `json:"description"`
	Payload     string    `json:"payload"`
	Request     string    `json:"request"`
	Response    string    `json:"response"`
	CreateTime  time.Time `json:"create_time"`
	NodeID      string    `json:"node_id,omitempty"`
	NodeName    string    `json:"node_name,omitempty"`
	Source      string    `json:"source"` // local
}

type VulnerabilityQuery struct {
	Page       int      `json:"page"`
	Limit      int      `json:"limit"`
	Plugin     string   `json:"plugin,omitempty"`
	Target     string   `json:"target,omitempty"`
	VulnType   string   `json:"vuln_type,omitempty"`
	Level      string   `json:"level,omitempty"`
	Source     string   `json:"source,omitempty"`
	NodeID     string   `json:"node_id,omitempty"`
	DateRange  []string `json:"date_range,omitempty"`
	SearchText string   `json:"search_text,omitempty"`
}

type VulnerabilityStats struct {
	Total     int                  `json:"total"`
	ByLevel   map[string]int       `json:"by_level"`
	ByPlugin  map[string]int       `json:"by_plugin"`
	BySource  map[string]int       `json:"by_source"`
	ByNode    map[string]int       `json:"by_node"`
	Recent24h int                  `json:"recent_24h"`
	Trend     []VulnerabilityTrend `json:"trend"`
}

type VulnerabilityTrend struct {
	Date  string `json:"date"`
	Count int    `json:"count"`
}

func NewVulnerabilityAPI() *VulnerabilityAPI {
	return &VulnerabilityAPI{}
}

// GetVulnerabilities 获取漏洞列表
func (v *VulnerabilityAPI) GetVulnerabilities(ctx context.Context, query VulnerabilityQuery) Result {
	if query.Page <= 0 {
		query.Page = 1
	}
	if query.Limit <= 0 {
		query.Limit = 50
	}

	vulnerabilities, total, err := v.getVulnerabilitiesFromSQLite(query)

	if err != nil {
		logging.Logger.Errorf("获取漏洞列表失败: %v", err)
		return Result{Error: "获取漏洞列表失败"}
	}

	return Result{Data: map[string]interface{}{
		"vulnerabilities": vulnerabilities,
		"total":           total,
		"page":            query.Page,
		"limit":           query.Limit,
	}}
}

// getVulnerabilitiesFromSQLite 从SQLite获取漏洞数据
func (v *VulnerabilityAPI) getVulnerabilitiesFromSQLite(query VulnerabilityQuery) ([]VulnerabilityData, int, error) {
	// 这里需要实现SQLite版本的查询逻辑
	// 简单起见，先返回空数据
	return []VulnerabilityData{}, 0, nil
}

// GetVulnerabilityStats 获取漏洞统计信息
func (v *VulnerabilityAPI) GetVulnerabilityStats(ctx context.Context) Result {
	stats, err := v.getVulnerabilityStatsFromSQLite()

	if err != nil {
		logging.Logger.Errorf("获取漏洞统计失败: %v", err)
		return Result{Error: "获取漏洞统计失败"}
	}

	return Result{Data: stats}
}

// getVulnerabilityStatsFromSQLite 从SQLite获取漏洞统计
func (v *VulnerabilityAPI) getVulnerabilityStatsFromSQLite() (VulnerabilityStats, error) {
	// 简单起见，返回空统计
	return VulnerabilityStats{
		ByLevel:  make(map[string]int),
		ByPlugin: make(map[string]int),
		BySource: make(map[string]int),
		ByNode:   make(map[string]int),
	}, nil
}

// ProcessVulnerabilityMessage 处理漏洞消息
func (v *VulnerabilityAPI) ProcessVulnerabilityMessage(vuln *output.VulMessage) error {
	if vuln == nil {
		return nil
	}

	// 漏洞消息处理逻辑（仅本地模式）
	logging.Logger.Infof("处理漏洞消息: %s - %s", vuln.Plugin, vuln.VulnData.Target)
	return nil
}

// DeleteVulnerability 删除漏洞
func (v *VulnerabilityAPI) DeleteVulnerability(ctx context.Context, id int) Result {
	// SQLite删除逻辑（待实现）
	return Result{Data: "删除成功"}
}

// ClearVulnerabilities 清空漏洞数据
func (v *VulnerabilityAPI) ClearVulnerabilities(ctx context.Context) Result {
	// SQLite清空逻辑（待实现）
	return Result{Data: "清空成功"}
}

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { 
  VulnerabilityItem, 
  VulnerabilityMessage, 
  VulnerabilityStatistics,
  VulnerabilityLevel
} from '../types';
// @ts-ignore 导入 Wails 后端函数
import { GetVulnerabilities, ClearVulnerabilities } from "../../bindings/github.com/yhy0/ChYing/app.js";

/**
 * 漏洞数据管理 Store
 * 
 * 数据来源：后端数据库
 * 实时更新：通过 Wails 事件接收新漏洞
 */
export const useVulnerabilityStore = defineStore('vulnerability', () => {
  // ==================== 状态定义 ====================
  
  // 所有漏洞数据 - 初始化为空数组，通过 loadFromDatabase 从数据库加载
  const vulnerabilities = ref<VulnerabilityItem[]>([]);
  
  // 加载状态
  const isLoading = ref(false);
  
  // 漏洞ID计数器，确保每个漏洞有唯一ID
  let vulnerabilityIdCounter = Date.now();
  
  // ==================== 计算属性 ====================
  
  // 漏洞总数
  const totalCount = computed(() => vulnerabilities.value.length);
  
  // 漏洞等级统计
  const levelStatistics = computed(() => {
    const stats = {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      info: 0
    };
    
    vulnerabilities.value.forEach(vuln => {
      switch (vuln.level?.toLowerCase()) {
        case 'critical':
          stats.critical++;
          break;
        case 'high':
          stats.high++;
          break;
        case 'medium':
          stats.medium++;
          break;
        case 'low':
          stats.low++;
          break;
        case 'info':
        case 'information':
          stats.info++;
          break;
      }
    });
    
    return stats;
  });
  
  // 便捷访问器：各等级漏洞数量
  const highCount = computed(() => levelStatistics.value.high);
  const mediumCount = computed(() => levelStatistics.value.medium);
  const lowCount = computed(() => levelStatistics.value.low);
  const infoCount = computed(() => levelStatistics.value.info);
  const criticalCount = computed(() => levelStatistics.value.critical);
  
  // 最近24小时内的漏洞数量
  const recent24hCount = computed(() => {
    const now = new Date();
    const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);
    
    return vulnerabilities.value.filter(vuln => {
      const createTime = new Date(vuln.createTime);
      return createTime >= yesterday;
    }).length;
  });
  
  // 按插件分组统计
  const pluginStatistics = computed(() => {
    const stats: Record<string, number> = {};
    
    vulnerabilities.value.forEach(vuln => {
      stats[vuln.plugin] = (stats[vuln.plugin] || 0) + 1;
    });
    
    return stats;
  });
  
  // 按漏洞类型分组统计
  const typeStatistics = computed(() => {
    const stats: Record<string, number> = {};
    
    vulnerabilities.value.forEach(vuln => {
      stats[vuln.vulnType] = (stats[vuln.vulnType] || 0) + 1;
    });
    
    return stats;
  });
  
  // 完整的统计信息
  const statistics = computed<VulnerabilityStatistics>(() => ({
    total: totalCount.value,
    critical: levelStatistics.value.critical,
    high: levelStatistics.value.high,
    medium: levelStatistics.value.medium,
    low: levelStatistics.value.low,
    recent24h: recent24hCount.value,
    byPlugin: pluginStatistics.value,
    byType: typeStatistics.value
  }));
  
  // 获取所有唯一的漏洞类型
  const availableTypes = computed(() => {
    const types = new Set<string>();
    vulnerabilities.value.forEach(vuln => types.add(vuln.vulnType));
    return Array.from(types);
  });
  
  // 获取所有唯一的插件名称
  const availablePlugins = computed(() => {
    const plugins = new Set<string>();
    vulnerabilities.value.forEach(vuln => plugins.add(vuln.plugin));
    return Array.from(plugins);
  });
  
  // ==================== 数据库操作方法 ====================
  
  /**
   * 从数据库加载漏洞数据
   * @param projectID 项目ID，空字符串或"all"获取所有项目
   * @param limit 限制数量，0表示不限制
   * @param offset 偏移量
   */
  const loadFromDatabase = async (projectID: string = '', limit: number = 500, offset: number = 0) => {
    isLoading.value = true;
    try {
      const result = await GetVulnerabilities(projectID, '', limit, offset);
      if (result.error) {
        console.error('从数据库加载漏洞数据失败:', result.error);
        return;
      }
      
      const dbVulnerabilities = result.data || [];

      // 转换数据库格式为前端格式
      vulnerabilities.value = dbVulnerabilities.map((dbVuln: any) => convertDbVulnToItem(dbVuln));
      
      // 更新ID计数器
      if (vulnerabilities.value.length > 0) {
        const maxId = Math.max(...vulnerabilities.value.map(v => v.id));
        vulnerabilityIdCounter = Math.max(vulnerabilityIdCounter, maxId + 1);
      }
    } catch (error) {
      console.error('加载漏洞数据异常:', error);
    } finally {
      isLoading.value = false;
    }
  };
  
  /**
   * 将数据库漏洞记录转换为前端 VulnerabilityItem 格式
   */
  const convertDbVulnToItem = (dbVuln: any): VulnerabilityItem => {
    const target = dbVuln.target || dbVuln.Target || '';
    const vulnType = dbVuln.vuln_type || dbVuln.VulnType || '未知类型';
    const createTime = dbVuln.created_at || dbVuln.CreatedAt || dbVuln.create_time || new Date().toISOString();
    
    // 解析目标URL
    let url = '', host = '', path = '';
    try {
      const urlObj = new URL(target.startsWith('http') ? target : `https://${target}`);
      url = urlObj.href;
      host = urlObj.hostname;
      path = urlObj.pathname + urlObj.search;
    } catch {
      url = target;
      host = target.split('/')[0] || '';
      path = '/' + target.split('/').slice(1).join('/');
    }
    
    return {
      id: dbVuln.id || dbVuln.ID || Date.now(),
      method: dbVuln.method || dbVuln.Method || 'GET',
      url: url,
      host: host,
      path: path,
      status: 200,
      length: dbVuln.response?.length || 0,
      mimeType: 'text/html',
      extension: '',
      title: vulnType,
      ip: dbVuln.ip || dbVuln.Ip || '',
      note: dbVuln.description || dbVuln.Description || '',
      timestamp: createTime,
      vulnType: vulnType,
      target: target,
      plugin: dbVuln.plugin || dbVuln.Plugin || '未知插件',
      level: (dbVuln.level || dbVuln.Level || 'info') as VulnerabilityLevel,
      createTime: createTime,
      description: dbVuln.description || dbVuln.Description,
      param: dbVuln.param || dbVuln.Param,
      payload: dbVuln.payload || dbVuln.Payload,
      curlCommand: dbVuln.curl_command || dbVuln.CurlCommand || '',
      request: dbVuln.request || dbVuln.Request,
      response: dbVuln.response || dbVuln.Response,
      selected: false
    };
  };
  
  // ==================== 实时数据操作方法 ====================
  
  /**
   * 处理后端漏洞消息批次（通过 Wails 事件接收）
   */
  const handleVulnerabilityMessages = (payload: { data: VulnerabilityMessage[] }) => {
    if (!payload || !Array.isArray(payload.data)) {
      console.warn('接收到的漏洞消息格式不正确:', payload);
      return;
    }

    const newVulnerabilities: VulnerabilityItem[] = [];
    
    payload.data.forEach((vulnMessage) => {
      const vulnData = vulnMessage.vul_data || vulnMessage.vulnData;
      
      if (!vulnData) {
        console.warn('跳过缺少vul_data/vulnData的漏洞项:', vulnMessage);
        return;
      }
      
      vulnerabilityIdCounter++;
      
      const target = vulnData.target || '';
      const vulnType = vulnData.vuln_type || vulnData.vulnType || '未知类型';
      const createTime = vulnData.create_time || vulnData.createTime || new Date().toISOString();
      const curlCommand = vulnData.curl_command || vulnData.curlCommand || '';
      
      let url = '', host = '', path = '';
      try {
        const urlObj = new URL(target.startsWith('http') ? target : `https://${target}`);
        url = urlObj.href;
        host = urlObj.hostname;
        path = urlObj.pathname + urlObj.search;
      } catch {
        url = target;
        host = target.split('/')[0] || '';
        path = '/' + target.split('/').slice(1).join('/');
      }
      
      const vulnItem: VulnerabilityItem = {
        id: vulnerabilityIdCounter,
        method: vulnData.method || 'GET',
        url: url,
        host: host,
        path: path,
        status: 200,
        length: vulnData.response?.length || 0,
        mimeType: 'text/html',
        extension: '',
        title: vulnType,
        ip: vulnData.ip || '',
        note: vulnData.description || '',
        timestamp: createTime,
        vulnType: vulnType,
        target: target,
        plugin: vulnMessage.plugin || '未知插件',
        level: vulnMessage.level as VulnerabilityLevel,
        createTime: createTime,
        description: vulnData.description,
        param: vulnData.param,
        payload: vulnData.payload,
        curlCommand: curlCommand,
        request: vulnData.request,
        response: vulnData.response,
        selected: false
      };
      
      newVulnerabilities.push(vulnItem);
    });
    
    // 添加到列表顶部（最新的在前面）
    vulnerabilities.value.unshift(...newVulnerabilities);
  };
  
  /**
   * 添加单个漏洞
   */
  const addVulnerability = (vuln: VulnerabilityItem) => {
    vulnerabilities.value.unshift(vuln);
  };
  
  /**
   * 移除指定ID的漏洞
   */
  const removeVulnerability = (id: number) => {
    const index = vulnerabilities.value.findIndex(vuln => vuln.id === id);
    if (index !== -1) {
      vulnerabilities.value.splice(index, 1);
    }
  };
  
  /**
   * 更新漏洞的选中状态
   */
  const setVulnerabilitySelected = (id: number, selected: boolean) => {
    const vuln = vulnerabilities.value.find(v => v.id === id);
    if (vuln) {
      vuln.selected = selected;
    }
  };
  
  /**
   * 设置漏洞的颜色标记
   */
  const setVulnerabilityColor = (id: number, color: string) => {
    const vuln = vulnerabilities.value.find(v => v.id === id);
    if (vuln) {
      vuln.color = color;
    }
  };
  
  /**
   * 清空所有漏洞数据（同时清空数据库）
   */
  const clearAllVulnerabilities = async () => {
    try {
      const result = await ClearVulnerabilities();
      if (result.error) {
        console.error('清空数据库漏洞数据失败:', result.error);
      }
    } catch (error) {
      console.error('清空漏洞数据异常:', error);
    }
    
    vulnerabilities.value = [];
    vulnerabilityIdCounter = Date.now();
  };

  /**
   * 清空漏洞数据并同步（兼容旧接口）
   */
  const clearAllVulnerabilitiesWithSync = async () => {
    await clearAllVulnerabilities();
  };
  
  /**
   * 根据过滤条件获取漏洞列表
   */
  const getFilteredVulnerabilities = (filter: {
    searchKeyword?: string;
    targetHost?: string;
    vulnTypes?: string[];
    plugins?: string[];
    levels?: VulnerabilityLevel[];
    dateRange?: {
      start?: string;
      end?: string;
    };
  }) => {
    let result = vulnerabilities.value;
    
    if (filter.searchKeyword) {
      const keyword = filter.searchKeyword.toLowerCase();
      result = result.filter(vuln => 
        vuln.vulnType.toLowerCase().includes(keyword) ||
        vuln.target.toLowerCase().includes(keyword) ||
        vuln.description?.toLowerCase().includes(keyword) ||
        vuln.plugin.toLowerCase().includes(keyword)
      );
    }
    
    if (filter.targetHost) {
      const host = filter.targetHost.toLowerCase();
      result = result.filter(vuln => vuln.target.toLowerCase().includes(host));
    }
    
    if (filter.vulnTypes && filter.vulnTypes.length > 0) {
      result = result.filter(vuln => filter.vulnTypes!.includes(vuln.vulnType));
    }
    
    if (filter.plugins && filter.plugins.length > 0) {
      result = result.filter(vuln => filter.plugins!.includes(vuln.plugin));
    }
    
    if (filter.levels && filter.levels.length > 0) {
      result = result.filter(vuln => filter.levels!.includes(vuln.level));
    }
    
    if (filter.dateRange?.start || filter.dateRange?.end) {
      result = result.filter(vuln => {
        const vulnDate = new Date(vuln.createTime);
        if (filter.dateRange!.start && vulnDate < new Date(filter.dateRange!.start)) {
          return false;
        }
        if (filter.dateRange!.end && vulnDate > new Date(filter.dateRange!.end)) {
          return false;
        }
        return true;
      });
    }
    
    return result;
  };
  
  /**
   * 清理过期数据（保留最近7天的数据）- 仅清理内存中的数据
   */
  const cleanupOldVulnerabilities = () => {
    const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);

    vulnerabilities.value = vulnerabilities.value.filter(vuln => {
      const vulnDate = new Date(vuln.createTime);
      return vulnDate >= sevenDaysAgo;
    });
  };

  /**
   * 获取存储信息
   */
  const getStorageInfo = () => {
    return {
      itemCount: vulnerabilities.value.length,
      sizeInBytes: 0,
      sizeInMB: 0
    };
  };

  /**
   * 清除测试数据（兼容旧接口，现在不需要了）
   */
  const clearTestData = () => {
    // 数据来自数据库，不需要清除测试数据
  };
  
  // 返回所有公开的状态、计算属性和方法
  return {
    // 状态
    vulnerabilities,
    isLoading,
    
    // 计算属性
    totalCount,
    levelStatistics,
    highCount,
    mediumCount,
    lowCount,
    infoCount,
    criticalCount,
    recent24hCount,
    pluginStatistics,
    typeStatistics,
    statistics,
    availableTypes,
    availablePlugins,
    
    // 方法
    loadFromDatabase,
    handleVulnerabilityMessages,
    addVulnerability,
    removeVulnerability,
    setVulnerabilitySelected,
    setVulnerabilityColor,
    clearAllVulnerabilities,
    clearAllVulnerabilitiesWithSync,
    getFilteredVulnerabilities,
    clearTestData,
    cleanupOldVulnerabilities,
    getStorageInfo
  };
});

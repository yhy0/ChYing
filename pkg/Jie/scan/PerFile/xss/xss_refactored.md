### XSS 扫描器检测逻辑总结

我们的XSS扫描器整合了两种核心的检测策略：**反射型XSS检测** 和 **DOM型XSS检测**，两者并行工作，以实现最大的覆盖范围和准确性。

---

#### 一、 反射型XSS检测逻辑（基于服务端响应）

此流程的核心是**通过AST比对进行精确验证，杜绝误报**。

*   **步骤 1：参数发现与探针注入**
    引擎首先会识别请求中的所有可变参数（GET或POST）。接着，它会为每个参数生成一个独一无二的随机字符串（“探针”），然后发送一个新请求，将探针作为参数值注入。

*   **步骤 2：回显检测与上下文的深度分析**
    引擎会检查服务器的响应中是否包含了这个探针。
    *   如果探针被找到，意味着存在回显。此时，引擎会立刻将响应内容解析成一个**抽象语法树（AST）**。
    *   接下来是关键一步——**精确上下文分析**。引擎会分析探针在AST中的位置，以确定其具体的回显环境：
        *   是在HTML标签内部？(`HTMLTagContext`)
        *   是在HTML属性中？(`HTMLAttributeContext`)
        *   是在HTML注释里？(`HTMLCommentContext`)
        *   还是在`<script>`标签内？如果在此，会启用JavaScript词法分析器进行更深入的判断：
            *   在JS字符串字面量中？(`JSStringLiteralContext`) (并记录是单引号、双引号还是反引号)
            *   在JS注释中？(`JSCommentContext`)
            *   还是在常规JS代码中？(`JSContext`)
    *   系统会为每个回显点创建一个`InjectionPoint`（注入点）对象，其中包含了**上下文类型**、**用于比对的原始AST**以及参数详情。

*   **步骤 3：智能化检测器调度**
    引擎会根据注入点的精确上下文类型，从一个映射表（Map）中**O(1)复杂度**地直接选取唯一合适的`Detector`（检测器）。例如，属性上下文的注入点只会交由`AttributeContextDetector`处理，避免了无效的扫描尝试。

*   **步骤 4：面向上下文的Payload生成**
    被选中的检测器会请求`PayloadManager`生成攻击载荷。管理器会根据注入点的精确上下文（例如“在双引号JS字符串内”），生成**针对性极强**的Payload（如 `";alert(1)//`），以最高效的方式逃逸当前上下文。同时，它还会根据预设的扫描模式（智能、深度等），应用URL编码、HTML实体编码等多种混淆策略。

*   **步骤 5：基于AST比对的无误报验证**
    对于每个生成的Payload，检测器都会发送一次攻击请求。收到响应后，会交由`Verifier`（验证器）进行最终确认。验证器**不会简单地在响应中搜索Payload**，而是采用更可靠的**差分AST比对**：
    *   它将攻击响应解析成一个新的AST。
    *   将这个新AST与注入点中保存的**原始AST**进行比对。
    *   只有当比对发现**DOM结构发生了有意义的变化**时，漏洞才会被确认。例如：
        *   **HTML上下文**：是否成功注入了一个新的、可执行的HTML标签（如`<svg>`）。
        *   **属性上下文**：是否成功为一个已有标签添加了新的事件处理器属性（如`onmouseover`）。
    *   这种基于结构变化的验证方式，从根本上消除了因简单字符串匹配而产生的大量误报。

*   **步骤 6：生成报告**
    一旦验证器确认漏洞，系统会生成详细的漏洞报告并输出。

---

#### 二、 DOM型XSS检测逻辑（基于客户端执行）

此流程为了平衡性能开销与检测深度，独创性地采用了**三层智能漏斗模型**。

*   **第一层：高速静态预筛选**
    引擎首先对原始页面内容进行一次极速的静态字符串搜索。它会检查页面是否**同时包含**已知的危险JS `Source`（如 `location.hash`）和危险JS `Sink`（如 `.innerHTML`）。只有当两者都存在时，该页面才被认为是“可疑的”，并进入下一层分析。这一步能以最小的开销排除掉绝大多数无关页面。

*   **第二层：AST语法验证**
    对于通过了第一层筛选的“可疑”页面，引擎会进行一次更严格的静态语法验证。它会解析页面中的JavaScript代码，并利用词法分析器确保在第一层找到的`Source`和`Sink`确实位于**可执行的代码**中，而不是碰巧出现在字符串或注释里。只有通过了此层验证的页面，才被认为是“高度可疑”的。

*   **第三层：基于无头浏览器的动态污点分析**
    对于“高度可疑”的页面，引擎将启动最终的动态分析武器：
    1.  **启动浏览器**：通过`rod`库启动一个无头Chrome浏览器实例。
    2.  **JS代码插桩**：引擎会拦截浏览器对所有JS文件的请求。在返回给浏览器之前，它会先将JS代码解析成AST，然后**重写AST**，在所有已知的`Source`和`Sink`函数外层包裹上我们的追踪探针（如 `__TaintTracker.source()` 和 `__TaintTracker.check()`）。
    3.  **执行与监控**：浏览器会执行被我们“插桩”后的JS代码。
    4.  **污点追踪**：如果在页面执行过程中，一个来自被标记的`Source`的数据，未经处理就直接流入了被标记的`Sink`，那么我们的 `check()` 探针就会被触发。
    5.  **实时上报**：被触发的探针会立刻通过我们预先注入到页面JS环境中的Go函数 (`window.reportTaint`)，将漏洞发现的信，包括具体的`Source`和`Sink`，实时报告给主引擎。

*   **生成报告**
    一旦收到动态分析器上报的漏洞信息，引擎便会确认DOM型XSS漏洞的存在，并生成详细报告。

通过这两套机制的协同工作，我们的XSS扫描器实现了对两类主要XSS漏洞的全面、高效且精准的自动化检测。
package db

import (
	"fmt"
	"time"

	"github.com/yhy0/logging"
)

/**
   @author yhy
   @since 2024/9/24
   @desc 漏洞数据管理
**/

// Vulnerability 漏洞数据表结构
type Vulnerability struct {
	ID          int64  `gorm:"primary_key;auto_increment" json:"id"`
	VulnID      string `gorm:"index;unique" json:"vuln_id"` // 漏洞唯一标识
	VulnType    string `gorm:"index" json:"vuln_type"`      // 漏洞类型
	Target      string `gorm:"index" json:"target"`         // 目标URL
	Host        string `gorm:"index" json:"host"`           // 主机
	Method      string `json:"method"`                      // HTTP方法
	Path        string `json:"path"`                        // 路径
	Plugin      string `gorm:"index" json:"plugin"`         // 插件名称
	Level       string `gorm:"index" json:"level"`          // 漏洞等级: Critical, High, Medium, Low
	IP          string `gorm:"index" json:"ip"`             // IP地址
	Param       string `json:"param"`                       // 参数
	Payload     string `json:"payload"`                     // 载荷
	Description string `json:"description"`                 // 描述
	CurlCommand string `json:"curl_command"`                // CURL命令
	Request     string `json:"request"`                     // 请求内容
	Response    string `json:"response"`                    // 响应内容

	// 新增字段用于区分漏洞来源
	Source   string `gorm:"index;default:'local'" json:"source"` // 漏洞来源: 'local' | 'remote' | 'crawler'
	SourceID string `gorm:"index" json:"source_id"`              // 来源标识: 本地IP或服务器ID
	NodeName string `json:"node_name"`                           // 节点名称: 便于识别

	// 项目标识字段
	ProjectID string `gorm:"index;default:'default'" json:"project_id"` // 项目ID，用于区分不同项目的数据

	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

// AddVulnerability 添加漏洞数据
func AddVulnerability(data *Vulnerability) error {
	// 设置默认值
	if data.Source == "" {
		data.Source = "local"
	}
	if data.SourceID == "" {
		data.SourceID = "localhost"
	}
	if data.NodeName == "" {
		data.NodeName = "本地节点"
	}
	if data.ProjectID == "" {
		data.ProjectID = "default"
	}

	// 使用 SQLite 数据库
	if GlobalDB == nil {
		logging.Logger.Warnln("数据库未初始化，无法添加漏洞数据")
		return fmt.Errorf("数据库未初始化")
	}

	if !GlobalDB.Migrator().HasTable(&Vulnerability{}) {
		err := GlobalDB.AutoMigrate(&Vulnerability{})
		if err != nil {
			logging.Logger.Errorln("Vulnerability Table Create err:", err)
			return err
		}
	}

	// 检查是否已存在相同的漏洞
	if !ExistVulnerability(data.VulnID) {
		err := GlobalDB.Create(&data).Error
		if err != nil {
			logging.Logger.Errorln("AddVulnerability err:", err)
			return err
		}
		logging.Logger.Infof("漏洞数据已入库: %s - %s", data.VulnType, data.Target)
	} else {
		logging.Logger.Debugf("漏洞已存在，跳过: %s", data.VulnID)
	}

	return nil
}

// AddRemoteVulnerability 添加远程漏洞数据
func AddRemoteVulnerability(data *Vulnerability, sourceID, nodeName string) error {
	data.Source = "remote"
	data.SourceID = sourceID
	data.NodeName = nodeName
	return AddVulnerability(data)
}

// AddCrawlerVulnerability 添加爬虫漏洞数据
func AddCrawlerVulnerability(data *Vulnerability, sourceID, nodeName string) error {
	data.Source = "crawler"
	data.SourceID = sourceID
	data.NodeName = nodeName
	return AddVulnerability(data)
}

// ExistVulnerability 检查漏洞是否存在
func ExistVulnerability(vulnID string) bool {
	if GlobalDB == nil {
		return false
	}
	var count int64
	GlobalDB.Model(&Vulnerability{}).Where("vuln_id = ?", vulnID).Count(&count)
	return count > 0
}

// GetAllVulnerabilities 获取所有漏洞数据，支持项目ID过滤
func GetAllVulnerabilities(projectID string, source string, limit, offset int) ([]*Vulnerability, error) {
	// 使用 SQLite 数据库
	var data []*Vulnerability
	query := GlobalDB.Model(&Vulnerability{})

	// 添加项目ID过滤
	if projectID != "" && projectID != "all" {
		query = query.Where("project_id = ?", projectID)
	}

	// 添加来源过滤
	if source != "" && source != "all" {
		query = query.Where("source = ?", source)
	}

	if limit > 0 {
		query = query.Order("created_at DESC").Limit(limit).Offset(offset)
	} else {
		query = query.Order("created_at DESC")
	}

	query.Find(&data)

	return data, nil
}

// GetVulnerabilityByID 根据ID获取漏洞数据
func GetVulnerabilityByID(id int64) (*Vulnerability, error) {
	if GlobalDB == nil {
		return nil, fmt.Errorf("数据库未初始化")
	}

	var vuln Vulnerability
	err := GlobalDB.Where("id = ?", id).First(&vuln).Error
	if err != nil {
		return nil, err
	}

	return &vuln, nil
}

// GetVulnerabilityByVulnID 根据漏洞ID获取漏洞数据
func GetVulnerabilityByVulnID(vulnID string) (*Vulnerability, error) {
	if GlobalDB == nil {
		return nil, fmt.Errorf("数据库未初始化")
	}

	var vuln Vulnerability
	err := GlobalDB.Where("vuln_id = ?", vulnID).First(&vuln).Error
	if err != nil {
		return nil, err
	}

	return &vuln, nil
}

// GetVulnerabilityStatistics 获取漏洞统计信息
func GetVulnerabilityStatistics(projectID string) (map[string]interface{}, error) {
	if GlobalDB == nil {
		return nil, fmt.Errorf("数据库未初始化")
	}

	stats := make(map[string]interface{})

	// 构建基础查询条件
	baseQuery := GlobalDB.Model(&Vulnerability{})
	if projectID != "" && projectID != "all" {
		baseQuery = baseQuery.Where("project_id = ?", projectID)
	}

	// 总数统计 - 使用新的查询实例
	var total int64
	baseQuery.Count(&total)
	stats["total"] = total

	// 按等级统计 - 使用新的查询实例
	var levelStats []struct {
		Level string `json:"level"`
		Count int64  `json:"count"`
	}
	levelQuery := GlobalDB.Model(&Vulnerability{})
	if projectID != "" && projectID != "all" {
		levelQuery = levelQuery.Where("project_id = ?", projectID)
	}
	levelQuery.Select("level, count(*) as count").Group("level").Find(&levelStats)

	levelMap := make(map[string]int64)
	for _, stat := range levelStats {
		levelMap[stat.Level] = stat.Count
	}
	stats["by_level"] = levelMap

	// 按插件统计 - 使用新的查询实例
	var pluginStats []struct {
		Plugin string `json:"plugin"`
		Count  int64  `json:"count"`
	}
	pluginQuery := GlobalDB.Model(&Vulnerability{})
	if projectID != "" && projectID != "all" {
		pluginQuery = pluginQuery.Where("project_id = ?", projectID)
	}
	pluginQuery.Select("plugin, count(*) as count").Group("plugin").Find(&pluginStats)

	pluginMap := make(map[string]int64)
	for _, stat := range pluginStats {
		pluginMap[stat.Plugin] = stat.Count
	}
	stats["by_plugin"] = pluginMap

	// 按类型统计 - 使用新的查询实例
	var typeStats []struct {
		VulnType string `json:"vuln_type"`
		Count    int64  `json:"count"`
	}
	typeQuery := GlobalDB.Model(&Vulnerability{})
	if projectID != "" && projectID != "all" {
		typeQuery = typeQuery.Where("project_id = ?", projectID)
	}
	typeQuery.Select("vuln_type, count(*) as count").Group("vuln_type").Find(&typeStats)

	typeMap := make(map[string]int64)
	for _, stat := range typeStats {
		typeMap[stat.VulnType] = stat.Count
	}
	stats["by_type"] = typeMap

	return stats, nil
}

// DeleteVulnerability 删除漏洞数据
func DeleteVulnerability(id int64) error {
	if GlobalDB == nil {
		return fmt.Errorf("数据库未初始化")
	}

	err := GlobalDB.Delete(&Vulnerability{}, id).Error
	if err != nil {
		logging.Logger.Errorln("DeleteVulnerability err:", err)
		return err
	}

	return nil
}

// ClearAllVulnerabilities 清空所有漏洞数据
func ClearAllVulnerabilities() error {
	// 清空 SQLite 数据库表
	if GlobalDB == nil {
		return fmt.Errorf("数据库未初始化")
	}

	err := GlobalDB.Exec("DELETE FROM vulnerabilities").Error
	if err != nil {
		logging.Logger.Errorln("ClearAllVulnerabilities err:", err)
		return err
	}

	logging.Logger.Infoln("所有漏洞数据已从数据库中清空")
	return nil
}

// ClearProjectVulnerabilities 清空指定项目的漏洞数据
func ClearProjectVulnerabilities(projectID string) error {
	if GlobalDB == nil {
		return fmt.Errorf("数据库未初始化")
	}

	err := GlobalDB.Where("project_id = ?", projectID).Delete(&Vulnerability{}).Error
	if err != nil {
		logging.Logger.Errorln("ClearProjectVulnerabilities err:", err)
		return err
	}

	logging.Logger.Infof("项目 %s 的漏洞数据已清空", projectID)
	return nil
}
